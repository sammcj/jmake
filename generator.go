package main

import (
	"fmt"
	"regexp"
	"strings"
)

var (
	// {{VAR}} interpolation -> $(VAR)
	interpolateRe = regexp.MustCompile(`\{\{([^}]+)\}\}`)

	// Backtick expression -> $(shell ...)
	backtickRe = regexp.MustCompile("`([^`]+)`")
)

// Generate produces Makefile content from a parsed Justfile.
// If listDefault is true and the default recipe calls `just --list`,
// a help target with echo statements is generated instead.
func Generate(jf *Justfile, listDefault bool) string {
	var b strings.Builder

	b.WriteString("# Generated by jmake - do not edit\n")
	b.WriteString("SHELL := /bin/bash\n\n")

	// Collect all target names for .PHONY.
	var phonyTargets []string
	for _, r := range jf.Recipes {
		phonyTargets = append(phonyTargets, r.Name)
	}
	for _, a := range jf.Aliases {
		phonyTargets = append(phonyTargets, a.Name)
	}
	if listDefault {
		phonyTargets = append(phonyTargets, "help")
	}
	if len(phonyTargets) > 0 {
		b.WriteString(".PHONY: ")
		b.WriteString(strings.Join(phonyTargets, " "))
		b.WriteString("\n\n")
	}

	// Variables.
	for _, v := range jf.Variables {
		prefix := ""
		if v.Export {
			prefix = "export "
		}
		if v.Backtick {
			fmt.Fprintf(&b, "%s%s := $(shell %s)\n", prefix, v.Name, v.Value)
		} else {
			fmt.Fprintf(&b, "%s%s := %s\n", prefix, v.Name, v.Value)
		}
	}
	if len(jf.Variables) > 0 {
		b.WriteString("\n")
	}

	// If listDefault, generate a help target as the first (default) target.
	if listDefault {
		writeHelpTarget(&b, jf)
	}

	// Recipes.
	for _, r := range jf.Recipes {
		if listDefault && isListDefault(&r) {
			continue // skip the original default recipe; replaced by help
		}

		if r.Doc != "" {
			fmt.Fprintf(&b, "# %s\n", r.Doc)
		}

		// Target line.
		b.WriteString(r.Name)
		b.WriteString(":")
		if len(r.Dependencies) > 0 {
			b.WriteString(" ")
			b.WriteString(strings.Join(r.Dependencies, " "))
		}
		b.WriteString("\n")

		// Body lines.
		for _, line := range r.Lines {
			converted := convertLine(line)
			fmt.Fprintf(&b, "\t%s\n", converted)
		}

		b.WriteString("\n")
	}

	// Aliases.
	for _, a := range jf.Aliases {
		fmt.Fprintf(&b, "%s: %s\n\n", a.Name, a.Target)
	}

	return b.String()
}

// convertLine transforms a single recipe body line from justfile to Makefile syntax.
func convertLine(line string) string {
	// Replace {{VAR}} with $(VAR).
	line = interpolateRe.ReplaceAllString(line, "$($1)")

	// Replace `cmd` with $(shell cmd).
	line = backtickRe.ReplaceAllString(line, "$$(shell $1)")

	return line
}

// isListDefault returns true if the recipe is the default recipe that just calls `just --list`.
func isListDefault(r *Recipe) bool {
	if r.Name != "default" {
		return false
	}
	if len(r.Lines) != 1 {
		return false
	}
	trimmed := strings.TrimSpace(r.Lines[0])
	return trimmed == "@just --list" || trimmed == "just --list"
}

// writeHelpTarget writes a Makefile help target that lists all recipes.
func writeHelpTarget(b *strings.Builder, jf *Justfile) {
	b.WriteString("# Show available recipes\n")
	b.WriteString("help:\n")
	b.WriteString("\t@echo 'Available recipes:'\n")

	for _, r := range jf.Recipes {
		if isListDefault(&r) {
			continue
		}

		label := r.Name

		// Show parameters.
		if len(r.Params) > 0 {
			label += " " + formatParams(r.Params)
		}

		if r.Doc != "" {
			fmt.Fprintf(b, "\t@echo '    %-20s # %s'\n", label, r.Doc)
		} else {
			fmt.Fprintf(b, "\t@echo '    %s'\n", label)
		}
	}
	b.WriteString("\n")
}

// formatParams formats a slice of Param into a display string.
func formatParams(params []Param) string {
	var parts []string
	for _, p := range params {
		s := p.Name
		switch p.Variadic {
		case "*":
			s = "*" + s
		case "+":
			s = "+" + s
		}
		if p.Default != "" {
			s += "=" + p.Default
		}
		parts = append(parts, s)
	}
	return strings.Join(parts, " ")
}

// ListRecipes prints a human-readable list of recipes, similar to `just --list`.
func ListRecipes(jf *Justfile) string {
	var b strings.Builder

	b.WriteString("Available recipes:\n")

	for _, r := range jf.Recipes {
		if isListDefault(&r) {
			continue
		}

		label := r.Name

		if len(r.Params) > 0 {
			label += " " + formatParams(r.Params)
		}

		if r.Doc != "" {
			fmt.Fprintf(&b, "    %-20s # %s\n", label, r.Doc)
		} else {
			fmt.Fprintf(&b, "    %s\n", label)
		}
	}

	return b.String()
}
